.. _ktbs-rest-tutorial:

Using kTBS with REST and Turtle
===============================

This tutorial aims at showing how to create :ref:`kTBS elements <restful-api>` directly through the REST_ API with Turtle_ descriptions. If you are not familiar with Turtle or RDF_, you might prefer the :ref:`JSON <ktbs-rest-jsonld-tutorial>` version of that tutorial.

.. _REST: http://en.wikipedia.org/wiki/Representational_state_transfer
.. _Turtle: http://www.w3.org/2007/02/turtle/primer/
.. _RDF: http://www.w3.org/RDF/


Tools
+++++

For interacting with the kTBS, we will use the simple HTTP client that is
embeded within every HTML page generated by kTBS.
To use it, just click on the ``edit`` button at the lower left of the page.

Don't forget, though, that this embeded client is only a convenience shortcut
for easily interacting with kTBS.
You can just as well use any HTTP client,
either interactive (such as `curl <http://curl.haxx.se/>`_)
or programmatic.



Create and populate a Stored Trace
++++++++++++++++++++++++++++++++++

In this first part, we will create and populate a stored trace.
But for this, we first need to create a Base that will host our traces.

The kTBS Root
-------------

The kTBS root is where all bases live.
It is automatically created when the kTBS is first launched. Its URI is that of the kTBS server, in our case: http://localhost:8001/ .

Create a new base
-----------------

To create a new base in our kTBS root,
we have to perform an HTTP POST request to it.

Visit the `kTBS root <http://localhost:8001>`_
and open the embeded HTTP client
by clicking to ``edit`` at the lower-left of the page.

In the HTTP client text-area,
we will provide a description of the base to be created,
which should look as follows:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .
    @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

    <> :hasBase <base1/>.

    <base1/>
        a :Base ;
        rdfs:label "My new base" .


then ensure that the content-type ``text/turtle`` is selected,
finally press the ``POST`` button.

You should be redirected to http://localhost:8001/base1/,
which is the URI of your newly created base,
and displays a description of your base.

.. note::

   All URIs in the example above
   are relative to the URI of the resource to which we post it;
   for example:

   * ``<>`` is interpreted as ``<http://localhost:8001/>``,
   * ``<base1/>`` is interpreted as ``<http://localhost:8001/base1/>``;

   this rule is true for all POST and PUT requests to the kTBS.



Create a stored trace
---------------------

Creating a stored trace inside a base
is very similar to creating a base in the kTBS root.
We first need to visit the `base <http://localhost:8001/base1/>`_
(you should already be there after the previous step).

In the HTTP client text-area,
we will provide a description of the stored trace to be created,
which should look like:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .

    <> :contains <t01/> .

    <t01/>
        a :StoredTrace ;
        :hasModel <http://liris.cnrs.fr/silex/2011/simple-trace-model/> ;
        :hasOrigin "1970-01-01T00:00:00Z" ;
        :hasDefaultSubject "me" .


As previously, ensure that the selected content-type is ``text/turtle``,
then press the ``POST`` button.
Again, you should be redirected to the newly created trace.

You will notice that, besides the properties that you set for the new trace,
the kTBS created another property, `hasObselCollection <http://liris.cnrs.fr/silex/2009/ktbs#hasObselCollection>`_,
pointing to http://localhost:8001/base1/t01/@obsels.
This is where
all the obsels that we are going to add to this trace will be created.


Add obsels to trace
-------------------

Adding an obsel to a trace should be no surprise to you at this point:
it is simply done by POSTing a description of the obsel to the trace itself.

Simply visit `the trace <http://localhost:8001/base1/t01/>`_
and POST the following content to it:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .
    @prefix m: <http://liris.cnrs.fr/silex/2011/simple-trace-model/> .

    <obs1> a m:SimpleObsel ;
        :hasTrace <> .

Being redirected to the description of the new obsel,
you will notice that this time the kTBS added a number of properties
in addition to the ones you specified above.
More precisely:

  * The ``begin`` and ``end`` of the obsel have been automatically set
    based on the moment you posted the obsel;
    this is expressed in milliseconds since the origin of the trace.

  * The ``subject`` of the obsel has been set based on the default subject
    of the trace. If we had not provided a default subject for the trace,
    then specifying the subject of each new obsel would be mandatory.

It would have been possible to specify those properties explicitly,
if we wanted to override the values automatically computed by the kTBS.

For example, let's go back to `the trace <http://localhost:8001/base1/t01/>`_
and POST the following content to it:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .
    @prefix m: <http://liris.cnrs.fr/silex/2011/simple-trace-model/> .

    <obs0> a m:SimpleObsel ;
        :hasTrace <> ;
        :hasBegin 1361462605000 ;
        :hasEnd   1361462647000 ;
        :hasSubject "someone else" .

We also note that, as with the base and the trace earlier,
we had to mint a URI for our new obsels.
As we are likely to create a large number of obsels,
it sounds like a good idea to leave it to the kTBS
to mint a fresh URI for each of them.
For our third obsel,
we will therefore use a `blank node <http://www.w3.org/TR/rdf-concepts/#section-blank-nodes>`_.
We will also add attributes and relations to our new obsel
to make it more interesting.

Let's go back to `the trace <http://localhost:8001/base1/t01/>`_
and POST the following content to it:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .
    @prefix m: <http://liris.cnrs.fr/silex/2011/simple-trace-model/> .

    [ a m:SimpleObsel ;
      :hasTrace <> ;
      m:value "a new obsel" ;
      m:hasRelatedObsel <obs1> ;
    ].

.. note::

   Every element of the kTBS can be created with a blank node instead of
   an explicit URI.
   The minted URI is always returned by the kTBS
   in the ``Location`` HTTP header.


If we follow the `hasObselCollection <http://liris.cnrs.fr/silex/2009/ktbs#hasObselCollection>`_ link from `our trace <http://localhost:8001/base1/t01/>`_,
to the `obsel collection <http://localhost:8001/base1/t01/@obsels>`_,
we can see the three obsels we have created so far
(your timestamps will obviously differ):

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .
    @prefix m: <http://liris.cnrs.fr/silex/2011/simple-trace-model/> .

    <@obsels> a :StoredTraceObsels .
    <.> :hasObselCollection <@obsels> .

    <obs0> a m:SimpleObsel;
        :hasBegin 1361462605000;
        :hasEnd 1361462647000;
        :hasSubject "someone else";
        :hasTrace <.> .    
    
    <obs1> a m:SimpleObsel;
        :hasBegin 1361462685837;
        :hasEnd 1361462685837;
        :hasSubject "me";
        :hasTrace <.> .

    <o-3k> a m:SimpleObsel;
        :hasBegin 1361462707201;
        :hasEnd 1361462707201;
        :hasSubject "me";
        :hasTrace <.>;
        m:hasRelatedObsel <obs1>;
        m:value "a new obsel" .


Creating computed traces
++++++++++++++++++++++++

The kTBS has a number of :doc:`builtin methods <../concepts/method>`
to create Computed Traces.
As their name implies, computed trace differ from stored trace by the fact that
their obsels are *computed* by the kTBS
(in application of the corresponding method)
rather than provided by external collectors.


Create a Computed Trace with a filter method
--------------------------------------------

Let's go back to the `base <http://localhost:8001/base1/>`_
and create a new computed trace by POSTing the following:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .

    <> :contains <filtered1/> .

    <filtered1/>
        a :ComputedTrace ;
        :hasMethod :filter ;
        :hasSource <t01/> ;
        :hasParameter "after=1361462641000" .

This create a computed trace named ``filtered1``
based on a *temporal filter*
which copies the obsels from ``t01`` obsels
situated *after* timestamp 1361462641000.
You may notice that we did not provide
any model nor origin for the computed trace;
those are automatically computed.

If you go and check the `obsel collection <http://localhost:8001/base1/filtered1/@obsels>`_ of this computed trace,
you will find two obsels.
More precisely, all obsels from ``t01`` have been copied,
except for ``obs0`` which has been filtered out,
as it is not entierly after timestamp 1361462641000.



Create a Computed Trace with a SPARQL query
-------------------------------------------

We will now define a more sophisticated computed trace,
using the powerful query language
`SPARQL <http://www.w3.org/TR/rdf-sparql-query/>`_.

Let's go back to the `base <http://localhost:8001/base1/>`_
and create a new computed trace by POSTing the following:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .

    <> :contains <joinRelated1/> .

    <joinRelated1/>
        a :ComputedTrace ;
        :hasMethod :sparql ;
        :hasSource <t01/> ;
        :hasParameter """sparql=
    PREFIX : <http://liris.cnrs.fr/silex/2009/ktbs#>
    PREFIX m:  <http://liris.cnrs.fr/silex/2011/simple-trace-model/>

    CONSTRUCT {
        [ a m:SimpleObsel ;
          m:value ?value ;
          :hasTrace <%(__destination__)s> ;
          :hasSubject ?subject ;
          :hasBegin ?begin ;
          :hasEnd ?end ;
          :hasSourceObsel ?o1, ?o2 ;
        ] .
    } WHERE {
        ?o2 :hasSubject ?subject ;
            :hasEnd ?end ;
            m:hasRelatedObsel ?o1 .
        ?o1 :hasBegin ?begin .
        OPTIONAL { ?o2 m:value ?value }
    }""" .


This create a computed trace named ``joinRelated1``
using a SPARQL construct query
to builds an obsel for each pair of related obsels in ``t01``,
inheriting its ``begin`` and ``end`` timestamps respectively from each of them.

.. note::

   It is frequent that SPARQL construct queries build obsels that comply
   with a model different from the source trace's.
   The target model can be specified with the special ``model`` parameter
   supported by the :doc:`sparql method <../concepts/method>`.


Create a Computed Trace with a fusion method
--------------------------------------------

We will now use the ``fusion`` method,
used to aggregate in a computed trace
the obsels from several source traces.

Let's go back to the `base <http://localhost:8001/base1/>`_
and create a new computed trace by POSTing the following:

.. code-block:: turtle

    @prefix : <http://liris.cnrs.fr/silex/2009/ktbs#> .

    <> :contains <fusioned1/> .

    <fusioned1/>
        a :ComputedTrace ;
        :hasMethod :fusion ;
        :hasSource <filtered1/>, <joinRelated1/> .

This creates a computed trace named ``fusioned1`` which is a merge of the ``filtered1`` and the ``joinRelated1`` traces.
